<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mlb_simulator.features.build_features API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mlb_simulator.features.build_features</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#using functions from data utils, constructs a featureset for a model
#from src.data.data_utils import query_mlb_db
#from src.features.sql_dataset_loader import SQLiteDataset

import sys
import os
import pathlib
current_dir = os.path.dirname(os.path.realpath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)

from data.data_utils import query_mlb_db
from features.sql_dataset_loader import SQLiteDataset
from torch.utils.data import DataLoader
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from copy import deepcopy
import logging
import torch
import pandas as pd

logger = logging.getLogger(__name__)
log_fmt = &#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;
logging.basicConfig(level=logging.INFO, format=log_fmt)

import warnings
warnings.simplefilter(action=&#39;ignore&#39;, category=FutureWarning)

PITCH_CHARACTERISITCS = [
    &#39;release_speed&#39;, &#39;release_spin_rate&#39;, &#39;release_extension&#39;,
    &#39;release_pos_x&#39;, &#39;release_pos_y&#39;, &#39;release_pos_z&#39;,
    &#39;spin_axis&#39;, &#39;pfx_x&#39;, &#39;pfx_z&#39;,
    &#39;vx0&#39;, &#39;vy0&#39;, &#39;vz0&#39;,
    &#39;ax&#39;, &#39;ay&#39;, &#39;az&#39;,
    &#39;plate_x&#39;, &#39;plate_z&#39;
]

def get_xgb_set(df, target_col, split=False, test_size=0.1):
    encoders = {} # to store encoders

    le = LabelEncoder()
    y = pd.DataFrame(le.fit_transform(df[target_col]), columns=[target_col])

    encoders[target_col] = deepcopy(le)

    X = df.drop(target_col, axis=1)

    X, encoders = encode_cat_cols(X, encoders)   

    if split:
        X_train, y_train, X_test, y_test = train_test_split(X, y, shuffle=False, test_size=test_size)
        return X_train, X_test, y_train, y_test, encoders
    
    return X, y, encoders

def get_xgb_set_regression(df, target_cols, split=False, test_size=0.1):
    encoders = {}
    y = df[target_cols]
    X = df.drop(target_cols, axis=1)
    X, encoders = encode_cat_cols(X, encoders)

    if split:
        X_train, y_train, X_test, y_test = train_test_split(X, y, shuffle=False, test_size=test_size)
        return X_train, X_test, y_train, y_test, encoders
    
    return X, y, encoders

def get_hit_classification_dataset(split=False, backtest_date=&#39;&#39;):
    if backtest_date:
       backtest_date = f&#39;and game_date &lt;= &#34;{backtest_date}&#34;&#39; 
    
    df = query_mlb_db(f&#34;&#34;&#34;
    SELECT
        CASE
            WHEN events IN (&#39;single&#39;) THEN &#39;single&#39;
            WHEN events IN (&#39;double&#39;) THEN &#39;double&#39;
            WHEN events IN (&#39;triple&#39;) THEN &#39;triple&#39;
            WHEN events IN (&#39;home_run&#39;) THEN &#39;home_run&#39;
            WHEN events IN (&#39;field_out&#39;) THEN &#39;field_out&#39;
            WHEN events IN (&#39;ground_out&#39;, &#39;force_out&#39;) THEN &#39;ground_out&#39;
            WHEN events IN (&#39;fly_out&#39;, &#39;sac_fly&#39;) THEN &#39;fly_out&#39;
            WHEN events IN (&#39;double_play&#39;, &#39;grounded_into_double_play&#39;, &#39;sac_fly_double_play&#39;) THEN &#39;double_play&#39;
            WHEN events IN (&#39;triple_play&#39;) THEN &#39;triple_play&#39;
            WHEN events IN (&#39;field_error&#39;) THEN &#39;fielding_error&#39;
            WHEN events IN (&#39;fielders_choice&#39;) THEN &#39;fielders_choice&#39;
            ELSE NULL
        END AS simplified_outcome,
        game_pk, batter,
        case when inning_topbot=&#39;Top&#39; then home_team else away_team end as &#39;fielding_team&#39;,
        game_year, outs_when_up, stand, 
        case when on_1b is not null then 1 else 0 end as on_1b,
        case when on_2b is not null then 1 else 0 end as on_2b,
        case when on_3b is not null then 1 else 0 end as on_3b,    
        launch_speed, launch_angle, ROUND((-(180 / PI()) * atan2(hc_x - 130, 213 - hc_y) + 90)) as spray_angle
    FROM
        Statcast
    WHERE type=&#39;X&#39;
    and game_year &gt; 2020
    and
    simplified_outcome &amp;
    game_year &amp; outs_when_up &amp; of_fielding_alignment &amp;
    launch_speed &amp; launch_angle &amp; spray_angle is not null
    {backtest_date}
    ORDER BY GAME_DATE ASC;
    &#34;&#34;&#34;)

    speed_df = query_mlb_db(&#39;select mlb_id as batter, speed from PlayerSpeed;&#39;)
    venue_df = query_mlb_db(&#39;select game_pk, venue_name from VenueGamePkMapping;&#39;)
    oaa_df = query_mlb_db(&#34;&#34;&#34;
        select o.year as &#39;game_year&#39;, t.STATCAST as &#39;fielding_team&#39;, o.oaa_rhh_standardized, o.oaa_lhh_standardized
        from TeamOAA o
        left join TeamIdMapping t on o.entity_id = t.TEAMID
    &#34;&#34;&#34;)
    oaa_df[&#39;game_year&#39;] = oaa_df[&#39;game_year&#39;].astype(int)

    df = df.merge(venue_df, how=&#39;left&#39;, on=&#39;game_pk&#39;)
    df = df.merge(speed_df, how=&#39;left&#39;, on=&#39;batter&#39;)
    df = df.merge(oaa_df, how=&#39;left&#39;, on=[&#39;game_year&#39;, &#39;fielding_team&#39;])
    df[&#39;speed&#39;] = df[&#39;speed&#39;].astype(float)
    df[&#39;speed&#39;] = df[&#39;speed&#39;].fillna(df[&#39;speed&#39;].mean())
    
    
    df[&#39;oaa&#39;] = df.apply(lambda row: row[&#39;oaa_rhh_standardized&#39;] if row[&#39;stand&#39;] ==&#39;R&#39; else row[&#39;oaa_lhh_standardized&#39;], axis=1)

    df = df.drop([&#39;batter&#39;, &#39;game_pk&#39;, &#39;oaa_rhh_standardized&#39;, &#39;oaa_lhh_standardized&#39;], axis=1)

    target_col = &#39;simplified_outcome&#39;
    return get_xgb_set(df, target_col=target_col, split=split)


def encode_cat_cols(X, encoders_dict):
    object_cols = [col for col in X.columns if X[col].dtype == &#39;object&#39;]
    for col in object_cols:
        le = LabelEncoder()
        X[col] = le.fit_transform(X[col])
        encoders_dict[col] = deepcopy(le)

    return X, encoders_dict

def get_hit_outcome_dataset(batter_id, split=False, backtest_date=&#39;&#39;):

    backtest_yr = None
    if backtest_date:
       backtest_date = f&#39;and game_date &lt;= &#34;{backtest_date}&#34;&#39; 
       backtest_yr = backtest_date[:4]

    #CAST(TAN((hc_x - 128) / (208 - hc_y)) * 180 / PI() * 0.75 AS INT) AS spray_angle,
    query_str = f&#34;&#34;&#34;
        select 
            game_pk, launch_speed, launch_angle, ROUND((-(180 / PI()) * atan2(hc_x - 130, 213 - hc_y) + 90)) as spray_angle,
            
            release_speed, 
            release_spin_rate, 
            release_extension,

            release_pos_x,
            release_pos_y,
            release_pos_z,
            
            spin_axis,
            pfx_x, pfx_z, 
            
            vx0, vy0, vz0,
            ax, ay, az,
            plate_x, plate_z
            
        from Statcast
        where batter={batter_id}
        and description = &#39;hit_into_play&#39;
        and

            launch_speed &amp;
            launch_angle &amp;
            spray_angle &amp;    
        
            release_speed &amp;
            release_spin_rate &amp;
            release_extension &amp;

            release_pos_x &amp;
            release_pos_y &amp;
            release_pos_z &amp;
            
            spin_axis &amp;
            pfx_x &amp; pfx_z &amp;
            
            vx0 &amp; vy0 &amp; vz0 &amp;
            ax &amp; ay &amp; az &amp;
            plate_x &amp; plate_z
        is not null
        {backtest_date}
        and game_pk in (
                select distinct game_pk
                from Statcast
                where batter = {batter_id}
                    {backtest_date}
                order by game_date desc
                limit 162
            )
        order by game_date asc, at_bat_number asc, pitch_number asc;
    &#34;&#34;&#34;

    df = query_mlb_db(query_str)

    #get park factors that affect hit distance based on backtest yr
    venue_df = query_mlb_db(&#39;select * from VenueGamePkMapping&#39;)
    park_factors_df = query_mlb_db(&#39;select * from ParkFactors&#39;)
    
    col_idx = 4
    if backtest_yr:
        for idx, col in enumerate(park_factors_df.columns):
            if backtest_yr in col:
                col_idx = idx
                break
    park_factors_df[&#39;distance_factor&#39;] = park_factors_df[park_factors_df.columns[col_idx:col_idx+3]].astype(float).mean(axis=1).fillna(0)
    cur_park_factors_df = park_factors_df[[&#39;venue_id&#39;, &#39;venue_name&#39;, &#39;distance_factor&#39;]].sort_values(by=&#39;distance_factor&#39;, ascending=False)


    df = df.merge(venue_df[[&#39;game_pk&#39;, &#39;venue_id&#39;]], on=&#39;game_pk&#39;, how=&#39;left&#39;)

    #venue_df[&#39;venue_id&#39;] = venue_df[&#39;venue_id&#39;].astype(int)
    #venue_df[&#39;game_pk&#39;] = venue_df[&#39;game_pk&#39;].astype(int)
    cur_park_factors_df[&#39;venue_id&#39;] = cur_park_factors_df[&#39;venue_id&#39;].astype(int)
    df[&#39;venue_id&#39;] = df[&#39;venue_id&#39;].astype(int)

    df = df.merge(cur_park_factors_df[[&#39;venue_id&#39;, &#39;distance_factor&#39;]], on=&#39;venue_id&#39;, how=&#39;left&#39;)

    df.drop([&#39;game_pk&#39;, &#39;venue_id&#39;], axis=1, inplace=True)

    #some spring training fields dont have statcast distance.
    df[&#39;distance_factor&#39;] = df[&#39;distance_factor&#39;].fillna(0)

    target_cols = [&#39;launch_speed&#39;, &#39;launch_angle&#39;, &#39;spray_angle&#39;]
    return get_xgb_set_regression(df, target_cols, split=split)

def get_pitch_outcome_dataset_xgb(batter_id, split=False, backtest_date=&#39;&#39;):

    if backtest_date:
       backtest_date = f&#39;and game_date &lt;= &#34;{backtest_date}&#34;&#39; 

    query_str = f&#34;&#34;&#34;
        select 
            case
                when description=&#39;swinging_strike&#39; or description=&#39;swinging_strike_blocked&#39; or description=&#39;called_strike&#39; or description=&#39;foul_tip&#39; 
                    or description=&#39;swinging_pitchout&#39; then &#39;strike&#39;
                when description=&#39;foul&#39; or description=&#39;foul_pitchout&#39; then &#39;foul&#39;
                when description=&#39;ball&#39; or description=&#39;blocked_ball&#39; or description=&#39;pitchout&#39; then &#39;ball&#39;
                when description=&#39;hit_by_pitch&#39; then &#39;hit_by_pitch&#39;
                when description=&#39;hit_into_play&#39; then &#39;hit_into_play&#39;
                else NULL
            end as pitch_outcome,
            
            pitch_number, strikes, balls,
            
            release_speed, 
            release_spin_rate, 
            release_extension,

            release_pos_x,
            release_pos_y,
            release_pos_z,
            
            spin_axis,
            pfx_x, pfx_z, 
            
            vx0, vy0, vz0,
            ax, ay, az,
            plate_x, plate_z
            
        from Statcast
        where batter={batter_id}
        /* and game_pk in (
                select distinct game_pk
                from Statcast
                where batter = {batter_id}
                    {backtest_date}
                order by game_date desc
                limit 324
        ) */
        and pitch_outcome &amp; p_throws &amp; pitch_number &amp; strikes &amp; balls &amp;
            release_speed &amp;
            release_spin_rate &amp;
            release_extension &amp;

            release_pos_x &amp;
            release_pos_y &amp;
            release_pos_z &amp;
            
            spin_axis &amp;
            pfx_x &amp; pfx_z &amp;
            
            vx0 &amp; vy0 &amp; vz0 &amp;
            ax &amp; ay &amp; az &amp;
            plate_x &amp; plate_z
        is not null
        {backtest_date}
        order by game_date asc, at_bat_number asc, pitch_number asc;
    &#34;&#34;&#34;

    df = query_mlb_db(query_str)

    target_col = &#39;pitch_outcome&#39;
    return get_xgb_set(df, target_col, split)
    
def get_pitch_outcome_dataset(batter_id, batch_size=32, shuffle=False):

    query_str = f&#34;&#34;&#34;
        select 
            case
                when description=&#39;swinging_strike&#39; or description=&#39;swinging_strike_blocked&#39; or description=&#39;called_strike&#39; or description=&#39;foul_tip&#39; 
                    or description=&#39;swinging_pitchout&#39; then &#39;strike&#39;
                when description=&#39;foul&#39; or description=&#39;foul_pitchout&#39; then &#39;foul&#39;
                when description=&#39;ball&#39; or description=&#39;blocked_ball&#39; or description=&#39;pitchout&#39; then &#39;ball&#39;
                when description=&#39;hit_by_pitch&#39; then &#39;hit_by_pitch&#39;
                when description=&#39;hit_into_play&#39; then &#39;hit_into_play&#39;
                else NULL
            end as pitch_outcome,
            
            p_throws, pitch_number, strikes, balls, outs_when_up,
            
            case
                when bat_score &gt; fld_score then 1
                when bat_score &lt; fld_score then -1
                else 0
            end as is_winning,
            
            release_speed, 
            release_spin_rate, 
            release_extension,

            release_pos_x,
            release_pos_y,
            release_pos_z,
            
            spin_axis,
            pfx_x, pfx_z, 
            
            vx0, vy0, vz0,
            ax, ay, az,
            plate_x, plate_z
            
        from Statcast
        where batter={batter_id}
        and pitch_outcome &amp; p_throws &amp; pitch_number &amp; strikes &amp; balls &amp; outs_when_up &amp; is_winning &amp;
            release_speed &amp;
            release_spin_rate &amp;
            release_extension &amp;

            release_pos_x &amp;
            release_pos_y &amp;
            release_pos_z &amp;
            
            spin_axis &amp;
            pfx_x &amp; pfx_z &amp;
            
            vx0 &amp; vy0 &amp; vz0 &amp;
            ax &amp; ay &amp; az &amp;
            plate_x &amp; plate_z
        is not null
        order by game_date asc, at_bat_number asc;
    &#34;&#34;&#34;


    logger.info(f&#39;Loading dataset for {batter_id}&#39;)

    #create pytorch dataset
    dataset = SQLiteDataset(query_str)

    logger.info(f&#39;Data successfully queried/transformed for {batter_id}&#39;)

    #ensure shuffle is false -&gt; uses oldest data for training, newest for val.
    train_set, val_set = train_test_split(dataset, test_size=0.25, shuffle=False)

    train_dataloader = DataLoader(train_set, batch_size=batch_size, shuffle=shuffle)
    val_dataloader = DataLoader(val_set, batch_size=len(val_set), shuffle=False)

    return train_dataloader, val_dataloader, dataset.num_target_classes, dataset.input_layer_size, dataset.label_encoders

def get_pitch_outcome_dataset_general(cluster_id, stands, batch_size=32, shuffle=False):
    
    cluster_query = f&#39;select batter from BatterStrikezoneCluster where cluster={cluster_id};&#39;
    
    batter_ids_in_cluster_df = query_mlb_db(cluster_query)
    batter_ids_in_cluster = batter_ids_in_cluster_df[&#39;batter&#39;].values

    sql_fmt_ids = &#39;, &#39;.join(map(str, batter_ids_in_cluster))


    query_str = f&#34;&#34;&#34;
        select 
            case
                when description=&#39;swinging_strike&#39; or description=&#39;swinging_strike_blocked&#39; or description=&#39;called_strike&#39; or description=&#39;foul_tip&#39; 
                    or description=&#39;swinging_pitchout&#39; then &#39;strike&#39;
                when description=&#39;foul&#39; or description=&#39;foul_pitchout&#39; then &#39;foul&#39;
                when description=&#39;ball&#39; or description=&#39;blocked_ball&#39; or description=&#39;pitchout&#39; then &#39;ball&#39;
                when description=&#39;hit_by_pitch&#39; then &#39;hit_by_pitch&#39;
                when description=&#39;hit_into_play&#39; then &#39;hit_into_play&#39;
                else NULL
            end as pitch_outcome,
            
            p_throws, pitch_number, strikes, balls, outs_when_up,
            
            case
                when bat_score &gt; fld_score then 1
                when bat_score &lt; fld_score then -1
                else 0
            end as is_winning,
            
            release_speed, 
            release_spin_rate, 
            release_extension,

            release_pos_x,
            release_pos_y,
            release_pos_z,
            
            spin_axis,
            pfx_x, pfx_z, 
            
            vx0, vy0, vz0,
            ax, ay, az,
            plate_x, plate_z
            
        from Statcast
        where batter in ({sql_fmt_ids})
        and stand=&#39;{stands}&#39;
        and pitch_outcome &amp; p_throws &amp; pitch_number &amp; strikes &amp; balls &amp; outs_when_up &amp; is_winning &amp;
            release_speed &amp;
            release_spin_rate &amp;
            release_extension &amp;

            release_pos_x &amp;
            release_pos_y &amp;
            release_pos_z &amp;
            
            spin_axis &amp;
            pfx_x &amp; pfx_z &amp;
            
            vx0 &amp; vy0 &amp; vz0 &amp;
            ax &amp; ay &amp; az &amp;
            plate_x &amp; plate_z
        is not null
        order by game_date asc, at_bat_number asc;
    &#34;&#34;&#34;


    logger.info(f&#39;Loading dataset for cluster {cluster_id}&#39;)

    #create pytorch dataset
    dataset = SQLiteDataset(query_str)

    logger.info(f&#39;Data successfully queried/transformed for cluster {cluster_id}&#39;)

    #ensure shuffle is false -&gt; uses oldest data for training, newest for val.
    train_set, val_set = train_test_split(dataset, test_size=0.25, shuffle=False)

    train_dataloader = DataLoader(train_set, batch_size=batch_size, shuffle=shuffle)
    val_dataloader = DataLoader(val_set, batch_size=len(val_set), shuffle=False)

    return train_dataloader, val_dataloader, dataset.num_target_classes, dataset.input_layer_size, dataset.label_encoders


    # kikuchi: 579328
    query_str = f&#34;&#34;&#34;
    SELECT 
        
        release_speed, release_spin_rate, release_extension,
        release_pos_x, release_pos_y, release_pos_z,
        spin_axis, pfx_x, pfx_z,
        vx0, vy0, vz0,
        ax, ay, az,
        plate_x, plate_z,
        
        CASE 
            WHEN stand is &#39;L&#39; THEN 0
            ELSE 1
        END as stand,
        ROW_NUMBER() OVER (PARTITION BY game_pk ORDER BY game_date, at_bat_number, pitch_number) /100 AS cumulative_pitch_number
    FROM 
        Statcast
    WHERE 
        pitcher = {pitcher_id} and pitch_Type = &#39;FF&#39;
        AND release_speed IS NOT NULL
        AND release_spin_rate IS NOT NULL
        AND release_extension IS NOT NULL
        AND release_pos_x IS NOT NULL
        AND release_pos_y IS NOT NULL
        AND release_pos_z IS NOT NULL
        AND spin_axis IS NOT NULL
        AND pfx_x IS NOT NULL
        AND pfx_z IS NOT NULL
        AND vx0 IS NOT NULL
        AND vy0 IS NOT NULL
        AND vz0 IS NOT NULL
        AND ax IS NOT NULL
        AND ay IS NOT NULL
        AND az IS NOT NULL
        AND plate_x IS NOT NULL
        AND plate_z IS NOT NULL
    ORDER BY 
        game_date ASC, 
        at_bat_number ASC,
        pitch_number ASC;
    &#34;&#34;&#34;

    pitch_data_df = query_mlb_db(query_str)

    conditioning_cols = [&#39;stand&#39;, &#39;cumulative_pitch_number&#39;]


    conditioning_df = pitch_data_df[conditioning_cols]
    non_conditioning_df = pitch_data_df.drop(conditioning_cols, axis=1)

    conditioning_tensor = torch.tensor(conditioning_df.values, dtype=torch.float32)
    non_conditioning_tensor = torch.tensor(non_conditioning_df.values, dtype=torch.float32)

    logger.info(f&#39;Loading pitch dataset for pitcher {pitcher_id}&#39;)
    logger.info(f&#39;Data successfully queried/transformed for {pitcher_id}&#39;)

    return non_conditioning_tensor, conditioning_tensor

def get_sequencing_dataset(pitcher, backtest_date=&#39;&#39;):

    #for backtesting, add date query to only use past data
    if backtest_date:
       backtest_date = f&#39;and game_date &lt;= &#34;{backtest_date}&#34;&#39; 
    
    pitcher_query_str = f&#34;&#34;&#34;
        SELECT game_year, pitch_type, batter, pitch_number, strikes, balls, outs_when_up, stand,
            CASE
                when on_1b is not null then 1
                else 0
            END AS on_1b,
            CASE
                when on_2b is not null then 1
                else 0
            END AS on_2b,
            CASE
                when on_3b is not null then 1
                else 0
            END AS on_3b,
            LAG(pitch_type) OVER (PARTITION BY game_pk, pitcher, at_bat_number ORDER BY pitch_number) AS prev_pitch,
            ROW_NUMBER() OVER (PARTITION BY game_pk, pitcher ORDER BY at_bat_number, pitch_number) AS cumulative_pitch_number
        FROM Statcast
        WHERE pitcher = {pitcher}
            AND pitch_type IS NOT NULL
            and pitch_type &lt;&gt; &#39;PO&#39;
            AND game_type &lt;&gt; &#39;E&#39; || &#39;S&#39;
            and game_pk in (
                select distinct game_pk
                from Statcast
                where pitcher = {pitcher}
                    {backtest_date}
                order by game_date desc
                limit 48
            )
        ORDER BY game_year, at_bat_number, pitch_number
    &#34;&#34;&#34;
    pitcher_df = query_mlb_db(pitcher_query_str).set_index(&#39;batter&#39;)
    pitch_arsenal = pitcher_df[&#39;pitch_type&#39;].unique()

    sql_pitch_arsenal = &#39;, &#39;.join(pitch_arsenal)
    
    #get datasets
    batter_query = lambda table: f&#34;select batter, {sql_pitch_arsenal} from {table}&#34;
    strike_df = query_mlb_db(batter_query(&#39;BatterStrikePctByPitchType&#39;)).set_index(&#39;batter&#39;).add_suffix(&#39;_strike&#39;)
    woba_df = query_mlb_db(batter_query(&#39;BatterAvgWobaByPitchType&#39;)).set_index(&#39;batter&#39;).add_suffix(&#39;_woba&#39;)


    df = pitcher_df.merge(strike_df, left_index=True, right_index=True, how=&#39;left&#39;)
    df = df.merge(woba_df, left_index=True, right_index=True, how=&#39;left&#39;)
    df.reset_index(drop=True, inplace=True)

    target_col = &#39;pitch_type&#39;
    encoders = {} # to store encoders

    le = LabelEncoder()
    y = pd.DataFrame(le.fit_transform(df[&#39;pitch_type&#39;]), columns=[target_col])

    encoders[target_col] = deepcopy(le)

    X = df.drop(target_col, axis=1)

    X, encoders = encode_cat_cols(X, encoders)   
    
    return X, y, encoders, pitch_arsenal


def get_pitches(pitcher_id, opposing_stance, pitch_type, backtest_date=&#39;&#39;):
    if backtest_date:
       backtest_date = f&#39;and game_date &lt;= &#34;{backtest_date}&#34;&#39; 
    pitch_df =  query_mlb_db(f&#39;&#39;&#39;select 
        {&#39;, &#39;.join(PITCH_CHARACTERISITCS)}, batter, strikes, balls
        from Statcast
        where pitcher={pitcher_id} and
        stand=&#34;{opposing_stance}&#34; and
        pitch_type=&#34;{pitch_type}&#34;
        and
        {&#39; &amp; &#39;.join(PITCH_CHARACTERISITCS)} 
        is not null
        AND game_type &lt;&gt; &#39;E&#39; || &#39;S&#39;
        {backtest_date}
        &#39;&#39;&#39;)

    if (l := len(pitch_df)) &lt; 50:
        logger.warning(f&#39;low pitch count ({l}) for {opposing_stance} {pitch_type}&#39;)

    sz_df = query_mlb_db(&#39;select * from BatterStrikezoneLookup&#39;)

    df = pd.merge(pitch_df, sz_df, on=&#39;batter&#39;, how=&#39;left&#39;).drop([&#39;batter&#39;], axis=1)

    return df

if __name__ == &#39;__main__&#39;:
    #train_dataloader, val_dataloader, num_features, num_classes, label_encoders = get_pitch_outcome_dataset(665489,batch_size=2)
    #for features, labels in train_dataloader:
        #print(f&#39;num features: {num_features} and num classes: {num_classes}&#39;)
        #print(f&#39;first batch features: {features}\n\n first batch labels: {labels}&#39;)
        #print(f&#39;label encoder: {label_encoders}&#39;)
        #break
    #train_dataloader, val_dataloader, num_classes, num_features, label_encoders = get_pitch_outcome_dataset_general(5,stands=&#39;R&#39;,batch_size=2)
    #for features, labels in train_dataloader:
        #print(f&#39;num features: {num_features} and num classes: {num_classes}&#39;)
        #print(f&#39;first batch features: {features}\n\n first batch labels: {labels}&#39;)
        #print(f&#39;label encoder: {label_encoders}&#39;)
        #print(f&#39;training batches: {len(train_dataloader)}, val batches: {len(val_dataloader)}&#39;)
       #break
    kukuchi = 579328
    jones = 683003

    pitcher = kukuchi

    all_pitches = get_pitches(pitcher,&#39;L&#39;,&#39;CU&#39;)
    print(all_pitches.head())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="mlb_simulator.features.build_features.encode_cat_cols"><code class="name flex">
<span>def <span class="ident">encode_cat_cols</span></span>(<span>X, encoders_dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def encode_cat_cols(X, encoders_dict):
    object_cols = [col for col in X.columns if X[col].dtype == &#39;object&#39;]
    for col in object_cols:
        le = LabelEncoder()
        X[col] = le.fit_transform(X[col])
        encoders_dict[col] = deepcopy(le)

    return X, encoders_dict</code></pre>
</details>
</dd>
<dt id="mlb_simulator.features.build_features.get_hit_classification_dataset"><code class="name flex">
<span>def <span class="ident">get_hit_classification_dataset</span></span>(<span>split=False, backtest_date='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hit_classification_dataset(split=False, backtest_date=&#39;&#39;):
    if backtest_date:
       backtest_date = f&#39;and game_date &lt;= &#34;{backtest_date}&#34;&#39; 
    
    df = query_mlb_db(f&#34;&#34;&#34;
    SELECT
        CASE
            WHEN events IN (&#39;single&#39;) THEN &#39;single&#39;
            WHEN events IN (&#39;double&#39;) THEN &#39;double&#39;
            WHEN events IN (&#39;triple&#39;) THEN &#39;triple&#39;
            WHEN events IN (&#39;home_run&#39;) THEN &#39;home_run&#39;
            WHEN events IN (&#39;field_out&#39;) THEN &#39;field_out&#39;
            WHEN events IN (&#39;ground_out&#39;, &#39;force_out&#39;) THEN &#39;ground_out&#39;
            WHEN events IN (&#39;fly_out&#39;, &#39;sac_fly&#39;) THEN &#39;fly_out&#39;
            WHEN events IN (&#39;double_play&#39;, &#39;grounded_into_double_play&#39;, &#39;sac_fly_double_play&#39;) THEN &#39;double_play&#39;
            WHEN events IN (&#39;triple_play&#39;) THEN &#39;triple_play&#39;
            WHEN events IN (&#39;field_error&#39;) THEN &#39;fielding_error&#39;
            WHEN events IN (&#39;fielders_choice&#39;) THEN &#39;fielders_choice&#39;
            ELSE NULL
        END AS simplified_outcome,
        game_pk, batter,
        case when inning_topbot=&#39;Top&#39; then home_team else away_team end as &#39;fielding_team&#39;,
        game_year, outs_when_up, stand, 
        case when on_1b is not null then 1 else 0 end as on_1b,
        case when on_2b is not null then 1 else 0 end as on_2b,
        case when on_3b is not null then 1 else 0 end as on_3b,    
        launch_speed, launch_angle, ROUND((-(180 / PI()) * atan2(hc_x - 130, 213 - hc_y) + 90)) as spray_angle
    FROM
        Statcast
    WHERE type=&#39;X&#39;
    and game_year &gt; 2020
    and
    simplified_outcome &amp;
    game_year &amp; outs_when_up &amp; of_fielding_alignment &amp;
    launch_speed &amp; launch_angle &amp; spray_angle is not null
    {backtest_date}
    ORDER BY GAME_DATE ASC;
    &#34;&#34;&#34;)

    speed_df = query_mlb_db(&#39;select mlb_id as batter, speed from PlayerSpeed;&#39;)
    venue_df = query_mlb_db(&#39;select game_pk, venue_name from VenueGamePkMapping;&#39;)
    oaa_df = query_mlb_db(&#34;&#34;&#34;
        select o.year as &#39;game_year&#39;, t.STATCAST as &#39;fielding_team&#39;, o.oaa_rhh_standardized, o.oaa_lhh_standardized
        from TeamOAA o
        left join TeamIdMapping t on o.entity_id = t.TEAMID
    &#34;&#34;&#34;)
    oaa_df[&#39;game_year&#39;] = oaa_df[&#39;game_year&#39;].astype(int)

    df = df.merge(venue_df, how=&#39;left&#39;, on=&#39;game_pk&#39;)
    df = df.merge(speed_df, how=&#39;left&#39;, on=&#39;batter&#39;)
    df = df.merge(oaa_df, how=&#39;left&#39;, on=[&#39;game_year&#39;, &#39;fielding_team&#39;])
    df[&#39;speed&#39;] = df[&#39;speed&#39;].astype(float)
    df[&#39;speed&#39;] = df[&#39;speed&#39;].fillna(df[&#39;speed&#39;].mean())
    
    
    df[&#39;oaa&#39;] = df.apply(lambda row: row[&#39;oaa_rhh_standardized&#39;] if row[&#39;stand&#39;] ==&#39;R&#39; else row[&#39;oaa_lhh_standardized&#39;], axis=1)

    df = df.drop([&#39;batter&#39;, &#39;game_pk&#39;, &#39;oaa_rhh_standardized&#39;, &#39;oaa_lhh_standardized&#39;], axis=1)

    target_col = &#39;simplified_outcome&#39;
    return get_xgb_set(df, target_col=target_col, split=split)</code></pre>
</details>
</dd>
<dt id="mlb_simulator.features.build_features.get_hit_outcome_dataset"><code class="name flex">
<span>def <span class="ident">get_hit_outcome_dataset</span></span>(<span>batter_id, split=False, backtest_date='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hit_outcome_dataset(batter_id, split=False, backtest_date=&#39;&#39;):

    backtest_yr = None
    if backtest_date:
       backtest_date = f&#39;and game_date &lt;= &#34;{backtest_date}&#34;&#39; 
       backtest_yr = backtest_date[:4]

    #CAST(TAN((hc_x - 128) / (208 - hc_y)) * 180 / PI() * 0.75 AS INT) AS spray_angle,
    query_str = f&#34;&#34;&#34;
        select 
            game_pk, launch_speed, launch_angle, ROUND((-(180 / PI()) * atan2(hc_x - 130, 213 - hc_y) + 90)) as spray_angle,
            
            release_speed, 
            release_spin_rate, 
            release_extension,

            release_pos_x,
            release_pos_y,
            release_pos_z,
            
            spin_axis,
            pfx_x, pfx_z, 
            
            vx0, vy0, vz0,
            ax, ay, az,
            plate_x, plate_z
            
        from Statcast
        where batter={batter_id}
        and description = &#39;hit_into_play&#39;
        and

            launch_speed &amp;
            launch_angle &amp;
            spray_angle &amp;    
        
            release_speed &amp;
            release_spin_rate &amp;
            release_extension &amp;

            release_pos_x &amp;
            release_pos_y &amp;
            release_pos_z &amp;
            
            spin_axis &amp;
            pfx_x &amp; pfx_z &amp;
            
            vx0 &amp; vy0 &amp; vz0 &amp;
            ax &amp; ay &amp; az &amp;
            plate_x &amp; plate_z
        is not null
        {backtest_date}
        and game_pk in (
                select distinct game_pk
                from Statcast
                where batter = {batter_id}
                    {backtest_date}
                order by game_date desc
                limit 162
            )
        order by game_date asc, at_bat_number asc, pitch_number asc;
    &#34;&#34;&#34;

    df = query_mlb_db(query_str)

    #get park factors that affect hit distance based on backtest yr
    venue_df = query_mlb_db(&#39;select * from VenueGamePkMapping&#39;)
    park_factors_df = query_mlb_db(&#39;select * from ParkFactors&#39;)
    
    col_idx = 4
    if backtest_yr:
        for idx, col in enumerate(park_factors_df.columns):
            if backtest_yr in col:
                col_idx = idx
                break
    park_factors_df[&#39;distance_factor&#39;] = park_factors_df[park_factors_df.columns[col_idx:col_idx+3]].astype(float).mean(axis=1).fillna(0)
    cur_park_factors_df = park_factors_df[[&#39;venue_id&#39;, &#39;venue_name&#39;, &#39;distance_factor&#39;]].sort_values(by=&#39;distance_factor&#39;, ascending=False)


    df = df.merge(venue_df[[&#39;game_pk&#39;, &#39;venue_id&#39;]], on=&#39;game_pk&#39;, how=&#39;left&#39;)

    #venue_df[&#39;venue_id&#39;] = venue_df[&#39;venue_id&#39;].astype(int)
    #venue_df[&#39;game_pk&#39;] = venue_df[&#39;game_pk&#39;].astype(int)
    cur_park_factors_df[&#39;venue_id&#39;] = cur_park_factors_df[&#39;venue_id&#39;].astype(int)
    df[&#39;venue_id&#39;] = df[&#39;venue_id&#39;].astype(int)

    df = df.merge(cur_park_factors_df[[&#39;venue_id&#39;, &#39;distance_factor&#39;]], on=&#39;venue_id&#39;, how=&#39;left&#39;)

    df.drop([&#39;game_pk&#39;, &#39;venue_id&#39;], axis=1, inplace=True)

    #some spring training fields dont have statcast distance.
    df[&#39;distance_factor&#39;] = df[&#39;distance_factor&#39;].fillna(0)

    target_cols = [&#39;launch_speed&#39;, &#39;launch_angle&#39;, &#39;spray_angle&#39;]
    return get_xgb_set_regression(df, target_cols, split=split)</code></pre>
</details>
</dd>
<dt id="mlb_simulator.features.build_features.get_pitch_outcome_dataset"><code class="name flex">
<span>def <span class="ident">get_pitch_outcome_dataset</span></span>(<span>batter_id, batch_size=32, shuffle=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pitch_outcome_dataset(batter_id, batch_size=32, shuffle=False):

    query_str = f&#34;&#34;&#34;
        select 
            case
                when description=&#39;swinging_strike&#39; or description=&#39;swinging_strike_blocked&#39; or description=&#39;called_strike&#39; or description=&#39;foul_tip&#39; 
                    or description=&#39;swinging_pitchout&#39; then &#39;strike&#39;
                when description=&#39;foul&#39; or description=&#39;foul_pitchout&#39; then &#39;foul&#39;
                when description=&#39;ball&#39; or description=&#39;blocked_ball&#39; or description=&#39;pitchout&#39; then &#39;ball&#39;
                when description=&#39;hit_by_pitch&#39; then &#39;hit_by_pitch&#39;
                when description=&#39;hit_into_play&#39; then &#39;hit_into_play&#39;
                else NULL
            end as pitch_outcome,
            
            p_throws, pitch_number, strikes, balls, outs_when_up,
            
            case
                when bat_score &gt; fld_score then 1
                when bat_score &lt; fld_score then -1
                else 0
            end as is_winning,
            
            release_speed, 
            release_spin_rate, 
            release_extension,

            release_pos_x,
            release_pos_y,
            release_pos_z,
            
            spin_axis,
            pfx_x, pfx_z, 
            
            vx0, vy0, vz0,
            ax, ay, az,
            plate_x, plate_z
            
        from Statcast
        where batter={batter_id}
        and pitch_outcome &amp; p_throws &amp; pitch_number &amp; strikes &amp; balls &amp; outs_when_up &amp; is_winning &amp;
            release_speed &amp;
            release_spin_rate &amp;
            release_extension &amp;

            release_pos_x &amp;
            release_pos_y &amp;
            release_pos_z &amp;
            
            spin_axis &amp;
            pfx_x &amp; pfx_z &amp;
            
            vx0 &amp; vy0 &amp; vz0 &amp;
            ax &amp; ay &amp; az &amp;
            plate_x &amp; plate_z
        is not null
        order by game_date asc, at_bat_number asc;
    &#34;&#34;&#34;


    logger.info(f&#39;Loading dataset for {batter_id}&#39;)

    #create pytorch dataset
    dataset = SQLiteDataset(query_str)

    logger.info(f&#39;Data successfully queried/transformed for {batter_id}&#39;)

    #ensure shuffle is false -&gt; uses oldest data for training, newest for val.
    train_set, val_set = train_test_split(dataset, test_size=0.25, shuffle=False)

    train_dataloader = DataLoader(train_set, batch_size=batch_size, shuffle=shuffle)
    val_dataloader = DataLoader(val_set, batch_size=len(val_set), shuffle=False)

    return train_dataloader, val_dataloader, dataset.num_target_classes, dataset.input_layer_size, dataset.label_encoders</code></pre>
</details>
</dd>
<dt id="mlb_simulator.features.build_features.get_pitch_outcome_dataset_general"><code class="name flex">
<span>def <span class="ident">get_pitch_outcome_dataset_general</span></span>(<span>cluster_id, stands, batch_size=32, shuffle=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pitch_outcome_dataset_general(cluster_id, stands, batch_size=32, shuffle=False):
    
    cluster_query = f&#39;select batter from BatterStrikezoneCluster where cluster={cluster_id};&#39;
    
    batter_ids_in_cluster_df = query_mlb_db(cluster_query)
    batter_ids_in_cluster = batter_ids_in_cluster_df[&#39;batter&#39;].values

    sql_fmt_ids = &#39;, &#39;.join(map(str, batter_ids_in_cluster))


    query_str = f&#34;&#34;&#34;
        select 
            case
                when description=&#39;swinging_strike&#39; or description=&#39;swinging_strike_blocked&#39; or description=&#39;called_strike&#39; or description=&#39;foul_tip&#39; 
                    or description=&#39;swinging_pitchout&#39; then &#39;strike&#39;
                when description=&#39;foul&#39; or description=&#39;foul_pitchout&#39; then &#39;foul&#39;
                when description=&#39;ball&#39; or description=&#39;blocked_ball&#39; or description=&#39;pitchout&#39; then &#39;ball&#39;
                when description=&#39;hit_by_pitch&#39; then &#39;hit_by_pitch&#39;
                when description=&#39;hit_into_play&#39; then &#39;hit_into_play&#39;
                else NULL
            end as pitch_outcome,
            
            p_throws, pitch_number, strikes, balls, outs_when_up,
            
            case
                when bat_score &gt; fld_score then 1
                when bat_score &lt; fld_score then -1
                else 0
            end as is_winning,
            
            release_speed, 
            release_spin_rate, 
            release_extension,

            release_pos_x,
            release_pos_y,
            release_pos_z,
            
            spin_axis,
            pfx_x, pfx_z, 
            
            vx0, vy0, vz0,
            ax, ay, az,
            plate_x, plate_z
            
        from Statcast
        where batter in ({sql_fmt_ids})
        and stand=&#39;{stands}&#39;
        and pitch_outcome &amp; p_throws &amp; pitch_number &amp; strikes &amp; balls &amp; outs_when_up &amp; is_winning &amp;
            release_speed &amp;
            release_spin_rate &amp;
            release_extension &amp;

            release_pos_x &amp;
            release_pos_y &amp;
            release_pos_z &amp;
            
            spin_axis &amp;
            pfx_x &amp; pfx_z &amp;
            
            vx0 &amp; vy0 &amp; vz0 &amp;
            ax &amp; ay &amp; az &amp;
            plate_x &amp; plate_z
        is not null
        order by game_date asc, at_bat_number asc;
    &#34;&#34;&#34;


    logger.info(f&#39;Loading dataset for cluster {cluster_id}&#39;)

    #create pytorch dataset
    dataset = SQLiteDataset(query_str)

    logger.info(f&#39;Data successfully queried/transformed for cluster {cluster_id}&#39;)

    #ensure shuffle is false -&gt; uses oldest data for training, newest for val.
    train_set, val_set = train_test_split(dataset, test_size=0.25, shuffle=False)

    train_dataloader = DataLoader(train_set, batch_size=batch_size, shuffle=shuffle)
    val_dataloader = DataLoader(val_set, batch_size=len(val_set), shuffle=False)

    return train_dataloader, val_dataloader, dataset.num_target_classes, dataset.input_layer_size, dataset.label_encoders


    # kikuchi: 579328
    query_str = f&#34;&#34;&#34;
    SELECT 
        
        release_speed, release_spin_rate, release_extension,
        release_pos_x, release_pos_y, release_pos_z,
        spin_axis, pfx_x, pfx_z,
        vx0, vy0, vz0,
        ax, ay, az,
        plate_x, plate_z,
        
        CASE 
            WHEN stand is &#39;L&#39; THEN 0
            ELSE 1
        END as stand,
        ROW_NUMBER() OVER (PARTITION BY game_pk ORDER BY game_date, at_bat_number, pitch_number) /100 AS cumulative_pitch_number
    FROM 
        Statcast
    WHERE 
        pitcher = {pitcher_id} and pitch_Type = &#39;FF&#39;
        AND release_speed IS NOT NULL
        AND release_spin_rate IS NOT NULL
        AND release_extension IS NOT NULL
        AND release_pos_x IS NOT NULL
        AND release_pos_y IS NOT NULL
        AND release_pos_z IS NOT NULL
        AND spin_axis IS NOT NULL
        AND pfx_x IS NOT NULL
        AND pfx_z IS NOT NULL
        AND vx0 IS NOT NULL
        AND vy0 IS NOT NULL
        AND vz0 IS NOT NULL
        AND ax IS NOT NULL
        AND ay IS NOT NULL
        AND az IS NOT NULL
        AND plate_x IS NOT NULL
        AND plate_z IS NOT NULL
    ORDER BY 
        game_date ASC, 
        at_bat_number ASC,
        pitch_number ASC;
    &#34;&#34;&#34;

    pitch_data_df = query_mlb_db(query_str)

    conditioning_cols = [&#39;stand&#39;, &#39;cumulative_pitch_number&#39;]


    conditioning_df = pitch_data_df[conditioning_cols]
    non_conditioning_df = pitch_data_df.drop(conditioning_cols, axis=1)

    conditioning_tensor = torch.tensor(conditioning_df.values, dtype=torch.float32)
    non_conditioning_tensor = torch.tensor(non_conditioning_df.values, dtype=torch.float32)

    logger.info(f&#39;Loading pitch dataset for pitcher {pitcher_id}&#39;)
    logger.info(f&#39;Data successfully queried/transformed for {pitcher_id}&#39;)

    return non_conditioning_tensor, conditioning_tensor</code></pre>
</details>
</dd>
<dt id="mlb_simulator.features.build_features.get_pitch_outcome_dataset_xgb"><code class="name flex">
<span>def <span class="ident">get_pitch_outcome_dataset_xgb</span></span>(<span>batter_id, split=False, backtest_date='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pitch_outcome_dataset_xgb(batter_id, split=False, backtest_date=&#39;&#39;):

    if backtest_date:
       backtest_date = f&#39;and game_date &lt;= &#34;{backtest_date}&#34;&#39; 

    query_str = f&#34;&#34;&#34;
        select 
            case
                when description=&#39;swinging_strike&#39; or description=&#39;swinging_strike_blocked&#39; or description=&#39;called_strike&#39; or description=&#39;foul_tip&#39; 
                    or description=&#39;swinging_pitchout&#39; then &#39;strike&#39;
                when description=&#39;foul&#39; or description=&#39;foul_pitchout&#39; then &#39;foul&#39;
                when description=&#39;ball&#39; or description=&#39;blocked_ball&#39; or description=&#39;pitchout&#39; then &#39;ball&#39;
                when description=&#39;hit_by_pitch&#39; then &#39;hit_by_pitch&#39;
                when description=&#39;hit_into_play&#39; then &#39;hit_into_play&#39;
                else NULL
            end as pitch_outcome,
            
            pitch_number, strikes, balls,
            
            release_speed, 
            release_spin_rate, 
            release_extension,

            release_pos_x,
            release_pos_y,
            release_pos_z,
            
            spin_axis,
            pfx_x, pfx_z, 
            
            vx0, vy0, vz0,
            ax, ay, az,
            plate_x, plate_z
            
        from Statcast
        where batter={batter_id}
        /* and game_pk in (
                select distinct game_pk
                from Statcast
                where batter = {batter_id}
                    {backtest_date}
                order by game_date desc
                limit 324
        ) */
        and pitch_outcome &amp; p_throws &amp; pitch_number &amp; strikes &amp; balls &amp;
            release_speed &amp;
            release_spin_rate &amp;
            release_extension &amp;

            release_pos_x &amp;
            release_pos_y &amp;
            release_pos_z &amp;
            
            spin_axis &amp;
            pfx_x &amp; pfx_z &amp;
            
            vx0 &amp; vy0 &amp; vz0 &amp;
            ax &amp; ay &amp; az &amp;
            plate_x &amp; plate_z
        is not null
        {backtest_date}
        order by game_date asc, at_bat_number asc, pitch_number asc;
    &#34;&#34;&#34;

    df = query_mlb_db(query_str)

    target_col = &#39;pitch_outcome&#39;
    return get_xgb_set(df, target_col, split)</code></pre>
</details>
</dd>
<dt id="mlb_simulator.features.build_features.get_pitches"><code class="name flex">
<span>def <span class="ident">get_pitches</span></span>(<span>pitcher_id, opposing_stance, pitch_type, backtest_date='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pitches(pitcher_id, opposing_stance, pitch_type, backtest_date=&#39;&#39;):
    if backtest_date:
       backtest_date = f&#39;and game_date &lt;= &#34;{backtest_date}&#34;&#39; 
    pitch_df =  query_mlb_db(f&#39;&#39;&#39;select 
        {&#39;, &#39;.join(PITCH_CHARACTERISITCS)}, batter, strikes, balls
        from Statcast
        where pitcher={pitcher_id} and
        stand=&#34;{opposing_stance}&#34; and
        pitch_type=&#34;{pitch_type}&#34;
        and
        {&#39; &amp; &#39;.join(PITCH_CHARACTERISITCS)} 
        is not null
        AND game_type &lt;&gt; &#39;E&#39; || &#39;S&#39;
        {backtest_date}
        &#39;&#39;&#39;)

    if (l := len(pitch_df)) &lt; 50:
        logger.warning(f&#39;low pitch count ({l}) for {opposing_stance} {pitch_type}&#39;)

    sz_df = query_mlb_db(&#39;select * from BatterStrikezoneLookup&#39;)

    df = pd.merge(pitch_df, sz_df, on=&#39;batter&#39;, how=&#39;left&#39;).drop([&#39;batter&#39;], axis=1)

    return df</code></pre>
</details>
</dd>
<dt id="mlb_simulator.features.build_features.get_sequencing_dataset"><code class="name flex">
<span>def <span class="ident">get_sequencing_dataset</span></span>(<span>pitcher, backtest_date='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sequencing_dataset(pitcher, backtest_date=&#39;&#39;):

    #for backtesting, add date query to only use past data
    if backtest_date:
       backtest_date = f&#39;and game_date &lt;= &#34;{backtest_date}&#34;&#39; 
    
    pitcher_query_str = f&#34;&#34;&#34;
        SELECT game_year, pitch_type, batter, pitch_number, strikes, balls, outs_when_up, stand,
            CASE
                when on_1b is not null then 1
                else 0
            END AS on_1b,
            CASE
                when on_2b is not null then 1
                else 0
            END AS on_2b,
            CASE
                when on_3b is not null then 1
                else 0
            END AS on_3b,
            LAG(pitch_type) OVER (PARTITION BY game_pk, pitcher, at_bat_number ORDER BY pitch_number) AS prev_pitch,
            ROW_NUMBER() OVER (PARTITION BY game_pk, pitcher ORDER BY at_bat_number, pitch_number) AS cumulative_pitch_number
        FROM Statcast
        WHERE pitcher = {pitcher}
            AND pitch_type IS NOT NULL
            and pitch_type &lt;&gt; &#39;PO&#39;
            AND game_type &lt;&gt; &#39;E&#39; || &#39;S&#39;
            and game_pk in (
                select distinct game_pk
                from Statcast
                where pitcher = {pitcher}
                    {backtest_date}
                order by game_date desc
                limit 48
            )
        ORDER BY game_year, at_bat_number, pitch_number
    &#34;&#34;&#34;
    pitcher_df = query_mlb_db(pitcher_query_str).set_index(&#39;batter&#39;)
    pitch_arsenal = pitcher_df[&#39;pitch_type&#39;].unique()

    sql_pitch_arsenal = &#39;, &#39;.join(pitch_arsenal)
    
    #get datasets
    batter_query = lambda table: f&#34;select batter, {sql_pitch_arsenal} from {table}&#34;
    strike_df = query_mlb_db(batter_query(&#39;BatterStrikePctByPitchType&#39;)).set_index(&#39;batter&#39;).add_suffix(&#39;_strike&#39;)
    woba_df = query_mlb_db(batter_query(&#39;BatterAvgWobaByPitchType&#39;)).set_index(&#39;batter&#39;).add_suffix(&#39;_woba&#39;)


    df = pitcher_df.merge(strike_df, left_index=True, right_index=True, how=&#39;left&#39;)
    df = df.merge(woba_df, left_index=True, right_index=True, how=&#39;left&#39;)
    df.reset_index(drop=True, inplace=True)

    target_col = &#39;pitch_type&#39;
    encoders = {} # to store encoders

    le = LabelEncoder()
    y = pd.DataFrame(le.fit_transform(df[&#39;pitch_type&#39;]), columns=[target_col])

    encoders[target_col] = deepcopy(le)

    X = df.drop(target_col, axis=1)

    X, encoders = encode_cat_cols(X, encoders)   
    
    return X, y, encoders, pitch_arsenal</code></pre>
</details>
</dd>
<dt id="mlb_simulator.features.build_features.get_xgb_set"><code class="name flex">
<span>def <span class="ident">get_xgb_set</span></span>(<span>df, target_col, split=False, test_size=0.1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xgb_set(df, target_col, split=False, test_size=0.1):
    encoders = {} # to store encoders

    le = LabelEncoder()
    y = pd.DataFrame(le.fit_transform(df[target_col]), columns=[target_col])

    encoders[target_col] = deepcopy(le)

    X = df.drop(target_col, axis=1)

    X, encoders = encode_cat_cols(X, encoders)   

    if split:
        X_train, y_train, X_test, y_test = train_test_split(X, y, shuffle=False, test_size=test_size)
        return X_train, X_test, y_train, y_test, encoders
    
    return X, y, encoders</code></pre>
</details>
</dd>
<dt id="mlb_simulator.features.build_features.get_xgb_set_regression"><code class="name flex">
<span>def <span class="ident">get_xgb_set_regression</span></span>(<span>df, target_cols, split=False, test_size=0.1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_xgb_set_regression(df, target_cols, split=False, test_size=0.1):
    encoders = {}
    y = df[target_cols]
    X = df.drop(target_cols, axis=1)
    X, encoders = encode_cat_cols(X, encoders)

    if split:
        X_train, y_train, X_test, y_test = train_test_split(X, y, shuffle=False, test_size=test_size)
        return X_train, X_test, y_train, y_test, encoders
    
    return X, y, encoders</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="mlb_simulator.features" href="index.html">mlb_simulator.features</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="mlb_simulator.features.build_features.encode_cat_cols" href="#mlb_simulator.features.build_features.encode_cat_cols">encode_cat_cols</a></code></li>
<li><code><a title="mlb_simulator.features.build_features.get_hit_classification_dataset" href="#mlb_simulator.features.build_features.get_hit_classification_dataset">get_hit_classification_dataset</a></code></li>
<li><code><a title="mlb_simulator.features.build_features.get_hit_outcome_dataset" href="#mlb_simulator.features.build_features.get_hit_outcome_dataset">get_hit_outcome_dataset</a></code></li>
<li><code><a title="mlb_simulator.features.build_features.get_pitch_outcome_dataset" href="#mlb_simulator.features.build_features.get_pitch_outcome_dataset">get_pitch_outcome_dataset</a></code></li>
<li><code><a title="mlb_simulator.features.build_features.get_pitch_outcome_dataset_general" href="#mlb_simulator.features.build_features.get_pitch_outcome_dataset_general">get_pitch_outcome_dataset_general</a></code></li>
<li><code><a title="mlb_simulator.features.build_features.get_pitch_outcome_dataset_xgb" href="#mlb_simulator.features.build_features.get_pitch_outcome_dataset_xgb">get_pitch_outcome_dataset_xgb</a></code></li>
<li><code><a title="mlb_simulator.features.build_features.get_pitches" href="#mlb_simulator.features.build_features.get_pitches">get_pitches</a></code></li>
<li><code><a title="mlb_simulator.features.build_features.get_sequencing_dataset" href="#mlb_simulator.features.build_features.get_sequencing_dataset">get_sequencing_dataset</a></code></li>
<li><code><a title="mlb_simulator.features.build_features.get_xgb_set" href="#mlb_simulator.features.build_features.get_xgb_set">get_xgb_set</a></code></li>
<li><code><a title="mlb_simulator.features.build_features.get_xgb_set_regression" href="#mlb_simulator.features.build_features.get_xgb_set_regression">get_xgb_set_regression</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>